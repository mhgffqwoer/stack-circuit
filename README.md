# Построение логических схем (Схема стека)

## Инструментарий

> Icarus Verilog version 12.0 (stable)

# Описание

## Описание работы "stack_behaviour_normal":

Схема использует 5 ячеек памяти (array[4:0]) для хранения данных. Для управления стеком используются сигналы: IODATA (данные для записи или чтения), INDEX (индекс ячейки), COMMAND (команда для выполнения операции), CLK (тактовый сигнал) и RESET (сброс схемы).

При срабатывании сигнала RESET все данные в массиве обнуляются, индексы сбрасываются, и флаг устанавливается в 0.

При поступлении команды записи (COMMAND == 01), данные записываются в текущую ячейку памяти, причем индекс увеличивается на 1 и циклически возвращается в начало, чтобы обеспечить работу стека.

При команде извлечения элемента стека (COMMAND == 10), данные извлекаются из последней ячейки, а индексы обновляются для корректного извлечения в дальнейшем.

При команде доступа к элементу по индексу (COMMAND == 11), сначала вычисляется индекс нужной ячейки, затем данные считываются из этой ячейки и передаются на выход.

Итоговый результат (IODATA) возвращается на выходе в зависимости от флага. Если флаг равен 1, то на выход идет полученный результат, иначе – неопределенное значение. 

Для одного элемента стека используется 4 бита памяти.

## Описание работы "stack_structural_normal":

### Модуль "rs_help":

Данная схема представляет собой вспомогательный модуль для реализации RS-триггера (Reset-Set). RS-триггер имеет два управляющих входа R (Reset) и S (Set), а также два выхода Q и инвертированный выход ~Q.

На входе модуля подаются сигналы R (reset) и S (set) вместе с входом reset (для ассинхронного сброса триггера). На выходе получаем сигналы q (Q) и inv_q (~Q).

Сначала происходит логическая операция OR между сигналами reset и inv_q, результат которой подается на выход inv_q. Это позволяет использовать сигнал reset для сброса триггера.

Далее происходят две логические операции NOR: между r и inv_q, результат которой подается на q, и между q и s, результат которой подается на res. Таким образом, управляющие сигналы R и S определяют состояние триггера: если R=0 и S=1, триггер устанавливается в 1; если R=1 и S=0, триггер сбрасывается в 0.

(На схеме этого модуля нет, тк он объединен с RS_trigger).

### Модуль "rs_trigger":

Основной модуль RS-триггера (обертка вокруг rs_help), который состоит из двух управляющих входов R (Reset) и S (Set), входов сброса (reset) и тактового сигнала (clk), а также двух выходов Q (q) и инвертированного выхода ~Q (invq).

На входе модуля подаются сигналы r (R), s (S), reset (для сброса триггера) и тактовый сигнал clk. На выходе получаем сигналы q (Q) и invq (~Q).

Сигналы R и S, а также сброс, передаются через логические элементы AND, с участием тактового сигнала clk, и сохраняются в новых сигналах newr и news. Это позволяет управлять установкой и сбросом триггера только по фронту тактового сигнала.

Затем новые сигналы newr и news, а также сигнал reset передаются во вспомогательный модуль rs_help и сохраняется в выходах q и invq.

###  Модуль "d_trigger":

Данный модуль представляет собой D-триггер, который имеет вход данных D, вход сброса (reset), тактовый вход (clk) и два выхода Q (q) и инвертированного выхода ~Q (invq).

На входе модуля передается сигнал d (D), а также сигналы сброса reset и тактового сигнала clk. На выходе получаем сигналы q (Q) и invq (~Q).

Сначала в модуле создается вспомогательный сигнал invd, который представляет инверсию входного сигнала D.

Затем инвертированный сигнал invd и исходный сигнал D, а также сигнал сброса reset и тактовый сигнал clk передаются в модуль rstrigger, который был представлен ранее.

### Модуль "rs_help_jk" и "rs_trigger_jk":

Реализованы так же как и "rs_trigger", отличие в логике ассинхронного сбрасывания. Реализованно для корректной работы JK-trigger'a.

### Модуль "jk_trigger":

В данном модуле реализован JK-триггер на основе двух RS-триггеров (rs_trigger_jk). JK-триггер имеет два управляющих входа J (set) и K (reset).

Модуль "jk_trigger" имеет следующие входы и выходы:
- `k`, `j`, `clk`, `reset`: входы для управления JK-триггером
- `q`, `inv_q`: выходы JK-триггера (Q и инверсия Q)
- new_k, new_j, temp_q, temp_inv_q, inv_clk: внутренние провода

Операции, выполняемые в модуле:
1. Инвертирование тактового сигнала `clk` с помощью элемента NOT, результат сохраняется в проводе `inv_clk`.
2. Логическое умножение между входом `k` и текущим значением `q`, результат сохраняется в проводе `new_k`.
3. Логическое умножение между входом `j` и инверсией текущего значения `q`, результат сохраняется в проводе `new_j`.
4. Первый RS-триггер rs1 получает новые значения `new_k` и `new_j`, тактовый сигнал `clk`, сигнал сброса reset и сохраняет результаты во временных проводах `temp_q` и `temp_inv_q`.
5. Второй RS-триггер `rs2` получает значения `temp_inv_q` и `temp_q`, инвертированный тактовый сигнал `inv_clk`, сигнал сброса reset и сохраняет результирующие значения в выходах `q` и `inv_q`.

Таким образом, данная схема с использованием двух RS-триггеров реализует JK-триггер, позволяя управлять установкой, сбросом и инверсией выходного значения с помощью входов `j` и `k`.

### Модуль "jk_counter":

Данный модуль представляет собой счетчик на JK-триггерах, который состоит из трех разрядов.

Входы:
- `clk`: тактовый сигнал для синхронизации операций счетчика
- `reset`: сигнал сброса, с помощью которого счетчик может быть сброшен в начальное состояние

Выходы:
- `o_data`: выходной сигнал, представляющий счетчик в виде трехразрядного числа


Использованы JK-триггеры и логические элементы для реализации счетчика
Имеется внутренний сигнал для управления сбросом в триггерах
Выходной сигнал представлен в формате трехразрядного числа

### Модуль "and_3":

Данный вспомогательный модуль реализует операцию AND между тремя входными сигналами `a0`, `a1` и `a2`. Результат операции записывается в выходной сигнал `res`.

### Модуль "or_5":

Данный вспомогательный модуль реализует операцию OR между тремя входными сигналами `a0`, `a1`, `a2`, `a3` и `a4`. Результат операции записывается в выходной сигнал `res`.

### Модуль "multi_and":

Данный модуль представляет собой четыре каскадных операции AND между четырьмя битами входного вектора `i_data` и сигналом `key`, результаты которых записываются в выходной вектор `o_data`.

Входы:
- `i_data`: входной вектор из четырех битов
- `key`: входной сигнал

Выходы:
- `o_data`: выходной вектор из четырех битов, результаты операций AND между соответствующими битами `i_data` и `key`

Используются четыре логических элемента `and`, каждый из которых выполняет операцию AND между одним из битов `i_data` и `key`

### Модуль "multi_or":

Описание:
Данный модуль представляет собой четыре каскадных операции OR между пятью битами из входных векторов `a0`, `a1`, `a2`, `a3`, `a4`, результаты которых записываются в соответствующие биты выходного вектора `o_data`.

Входы:
- `a0`, `a1`, `a2`, `a3`, `a4`: входные векторы из четырех битов
- Каждый бит из `a0`, `a1`, `a2`, `a3`, `a4` участвует в операции OR
- Выход от пяти операций OR подается на соответствующие биты вектора `o_data`

Выходы:
- `o_data: выходной вектор из четырех битов, результаты операций OR между соответствующими пятью битами из входных векторов

Используются четыре экземпляра модуля `or_5`, каждый из которых выполняет операцию OR между пятью входными битами
Результаты операций OR записываются в соответствующие биты выходного вектора `o_data`

### Модули "check_":

Реализованы пять модулей: "check_0", "check_1", "check_2", "check_3" и "check_4", которые преобразовывают чсило из двоичной системы счисления в десятичную. 

Входы:
- `i_data`: входное число в двоичной системе

Выходы:
- `o_data`: выходной провод, показывающий равенство. (Например: при подаче числа 001 загористся только "check_1")

Реализовано с помощью отрицания (NOT) и вспомогательного модуля (and_3)

### Модуль "my_checker":

(На схеме назван "checker")
Данный блок служит для обеспечения правильности работы с той или иной командой.

### Модули "idx_converter" и "idx_converter_negative":

Данные модули реализуют инкремент и декремент, за исключением:
 - --0000 = 0100
 - ++0100 = 0000

Входы:
- `i_data`: входное индекс в двоичной системе

Выходы:
- `o_data`: выходной индекс (--/++) в двоичной системе 

(На схеме это один модуль, а в коде он разбит еще на дополнительные модули "conv" и "parse"). Опирация выполняется с помощью простых побитовых преобразований.

### Модуль "idx_mod_5":

Данный модуль реализует остаток от деления на 5 (% 5) с помощью побитовых преобразований.

Входы:
- `i_data:` входное индекс в двоичной системе

Выходы:
- `o_data`: выходной индекс (% 5) в двоичной системе 

### Модуль "Memory_4bits":

Сам блок памяти на 4 бита, который реализован с помощью D-trigger'а

Входы:
- `i_data`: входное число которое нужно записать
- `reset`: для очистки памяти.
- `clk` и `key`: для записи (запись осуществляется если `сlk` and `key` = 1, `key` это указатель из счетчика на элемент куда нужно записывать)

Выходы:
- `o_data`: выходное число

### модули "my_stack" и "stack_structural_normal":

В модуле "my_stack" реализована основная работа стка на основе логики (stack_behaviour), собраная из вышеуказанных модулей. (тут реализация на разных проводах вода и выхода)

В модуле "stack_structural_normal" обединение входа и выхода на основе модуля "my_stack", а так же небольшие логичесские изменения, чтобы схема удовлетворяла каверзным тестам :D .
